/**
 * CyberGhost VPN Provider Implementation
 * Config-file-based via OpenVPN/WireGuard — API-assisted server list
 */

import { BaseVPNProvider } from './base.js';
import { createLogger } from '@nself/plugin-utils';
import type {
  ConnectVPNRequest,
  VPNConnectionRecord,
  VPNCredentialRecord,
  VPNServerRecord,
  VPNStatus,
  VPNProtocol,
} from '../types.js';

const logger = createLogger('vpn:cyberghost');

interface CyberGhostServer {
  id: string;
  name: string;
  country_code: string;
  country: string;
  city?: string;
  ip_address: string;
  load: number;
  status: string;
  protocols: string[];
  features?: string[];
}

interface CyberGhostServerListResponse {
  servers: CyberGhostServer[];
}

interface CyberGhostConfigResponse {
  openvpn_config?: string;
  wireguard_config?: string;
  server_ip: string;
  server_hostname: string;
}

export class CyberGhostProvider extends BaseVPNProvider {
  readonly name = 'cyberghost' as const;
  readonly displayName = 'CyberGhost VPN';
  readonly cliAvailable = false;
  readonly apiAvailable = true;
  readonly portForwardingSupported = false;
  readonly p2pAllServers = false;

  private readonly apiEndpoint = 'https://my.cyberghostvpn.com/api/v1';
  private sessionToken: string | null = null;
  private activeInterface: string | null = null;
  private activeVpnIp: string | null = null;

  // ============================================================================
  // Initialization
  // ============================================================================

  protected async checkCLIInstalled(): Promise<void> {
    // CyberGhost does not provide a Linux CLI; connections use OpenVPN or WireGuard
    // config files generated by the API. Verify that the required tools are present.
    try {
      await this.executeCommand('which openvpn');
      logger.info('CyberGhost: OpenVPN is available for config-file connections');
    } catch {
      logger.warn('CyberGhost: openvpn not found — WireGuard-only mode');
    }

    try {
      await this.executeCommand('which wg-quick');
      logger.info('CyberGhost: WireGuard (wg-quick) is available');
    } catch {
      logger.warn('CyberGhost: wg-quick not found — OpenVPN-only mode');
    }
  }

  protected async performAuthentication(credentials: VPNCredentialRecord): Promise<boolean> {
    try {
      if (!credentials.username || !credentials.password_encrypted) {
        throw new Error('CyberGhost requires username and password');
      }

      const response = await fetch(`${this.apiEndpoint}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: credentials.username,
          password: credentials.password_encrypted,
        }),
      });

      if (!response.ok) {
        const errText = await response.text();
        throw new Error(`Authentication failed: ${response.status} ${errText}`);
      }

      const data: { session_token: string } = await response.json();
      this.sessionToken = data.session_token;

      logger.info('Successfully authenticated with CyberGhost VPN');
      return true;
    } catch (error) {
      logger.error('CyberGhost authentication failed', {
        error: error instanceof Error ? error.message : String(error),
      });
      return false;
    }
  }

  // ============================================================================
  // Server Management
  // ============================================================================

  async fetchServers(): Promise<VPNServerRecord[]> {
    logger.info('Fetching CyberGhost server list from API');

    try {
      const response = await fetch(`${this.apiEndpoint}/servers`, {
        headers: this.authHeaders(),
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.statusText}`);
      }

      const data: CyberGhostServerListResponse = await response.json();
      const servers = data.servers ?? [];
      logger.info(`Fetched ${servers.length} servers from CyberGhost`);

      return servers.map((server) => this.mapServer(server));
    } catch (error) {
      logger.error('Failed to fetch CyberGhost servers', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  private mapServer(server: CyberGhostServer): VPNServerRecord {
    const protocols: VPNProtocol[] = [];
    for (const p of server.protocols ?? []) {
      if (p === 'wireguard') protocols.push('wireguard');
      else if (p.includes('udp')) protocols.push('openvpn_udp');
      else if (p.includes('tcp')) protocols.push('openvpn_tcp');
      else if (p === 'ikev2') protocols.push('ikev2');
    }
    if (protocols.length === 0) {
      protocols.push('openvpn_udp', 'openvpn_tcp', 'wireguard');
    }

    const features = server.features ?? [];
    const isP2P = features.includes('p2p') || features.includes('torrent');

    return {
      id: `cyberghost-${server.id}`,
      provider_id: 'cyberghost',
      hostname: server.ip_address,
      ip_address: server.ip_address,
      country_code: (server.country_code ?? '').toUpperCase(),
      country_name: server.country,
      city: server.city,
      p2p_supported: isP2P,
      port_forwarding_supported: false,
      protocols,
      load: server.load,
      status: server.status === 'online' ? 'online' : 'offline',
      features,
      owned: true,
      metadata: { server_name: server.name },
      last_seen: new Date(),
      created_at: new Date(),
      updated_at: new Date(),
    } as VPNServerRecord;
  }

  // ============================================================================
  // Connection Management
  // ============================================================================

  async connect(request: ConnectVPNRequest, credentials: VPNCredentialRecord): Promise<VPNConnectionRecord> {
    this.ensureAuthenticated();

    logger.info('Connecting to CyberGhost VPN via config file', {
      region: request.region,
      server: request.server,
      protocol: request.protocol,
    });

    const protocol = request.protocol ?? 'openvpn_udp';

    // Fetch a connection config from the API
    const configPayload: Record<string, unknown> = {
      protocol: this.mapProtocol(protocol as VPNProtocol),
    };
    if (request.server) configPayload['server_id'] = request.server;
    else if (request.region) configPayload['country_code'] = request.region.toUpperCase();

    const configResponse = await fetch(`${this.apiEndpoint}/servers/connect`, {
      method: 'POST',
      headers: { ...this.authHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify(configPayload),
    });

    if (!configResponse.ok) {
      const errText = await configResponse.text();
      throw new Error(`Failed to get connection config: ${configResponse.status} ${errText}`);
    }

    const configData: CyberGhostConfigResponse = await configResponse.json();

    try {
      // Apply the configuration and bring the tunnel up
      if (configData.wireguard_config && protocol === 'wireguard') {
        await this.applyWireGuardConfig(configData.wireguard_config);
        this.activeInterface = 'wg-cyberghost';
      } else if (configData.openvpn_config) {
        await this.applyOpenVPNConfig(configData.openvpn_config);
        this.activeInterface = 'tun0';
      } else {
        throw new Error('No supported VPN config returned by CyberGhost API');
      }

      // Fetch the VPN IP after the tunnel is up
      const vpnIp =
        (await this.getInterfaceIP(this.activeInterface)) ??
        configData.server_ip;
      this.activeVpnIp = vpnIp;

      logger.info('CyberGhost connection established', {
        interface: this.activeInterface,
        vpn_ip: vpnIp,
      });

      const connection: VPNConnectionRecord = {
        id: `cyberghost-${Date.now()}`,
        provider_id: 'cyberghost',
        server_id: undefined,
        protocol: protocol as VPNProtocol,
        status: 'connected',
        local_ip: undefined,
        vpn_ip: vpnIp,
        interface_name: this.activeInterface,
        dns_servers: [],
        connected_at: new Date(),
        kill_switch_enabled: request.kill_switch !== false,
        requested_by: request.requested_by,
        metadata: { server_hostname: configData.server_hostname },
        created_at: new Date(),
      };

      return connection;
    } catch (error) {
      logger.error('CyberGhost connection failed', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw new Error(`Failed to connect to CyberGhost VPN: ${error}`);
    }
  }

  async disconnect(connectionId: string): Promise<void> {
    logger.info('Disconnecting from CyberGhost VPN', { connectionId });

    try {
      if (this.activeInterface?.startsWith('wg')) {
        await this.executeCommand(`wg-quick down ${this.activeInterface}`);
      } else {
        await this.executeCommand('pkill -f openvpn').catch(() => {});
      }

      this.activeInterface = null;
      this.activeVpnIp = null;

      logger.info('Successfully disconnected from CyberGhost VPN');
    } catch (error) {
      logger.error('Failed to disconnect from CyberGhost VPN', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  async getStatus(): Promise<VPNStatus> {
    if (!this.activeInterface) {
      return { connected: false };
    }

    try {
      const ip = await this.getInterfaceIP(this.activeInterface);
      const connected = ip !== null;

      return {
        connected,
        vpn_ip: ip ?? this.activeVpnIp ?? undefined,
        interface: this.activeInterface,
        protocol: this.activeInterface.startsWith('wg') ? 'wireguard' : 'openvpn',
      };
    } catch (error) {
      logger.error('Failed to get CyberGhost status', {
        error: error instanceof Error ? error.message : String(error),
      });
      return { connected: false };
    }
  }

  // ============================================================================
  // Kill Switch
  // ============================================================================

  async enableKillSwitch(): Promise<void> {
    logger.info('Enabling iptables kill switch for CyberGhost');

    try {
      const iface = this.activeInterface ?? 'tun0';
      await this.executeCommand(
        `iptables -I OUTPUT ! -o ${iface} -m state --state NEW -j DROP`
      );
      logger.info('Kill switch enabled');
    } catch (error) {
      logger.error('Failed to enable kill switch', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  async disableKillSwitch(): Promise<void> {
    logger.info('Disabling iptables kill switch for CyberGhost');

    try {
      const iface = this.activeInterface ?? 'tun0';
      await this.executeCommand(
        `iptables -D OUTPUT ! -o ${iface} -m state --state NEW -j DROP`
      ).catch(() => {});
      logger.info('Kill switch disabled');
    } catch (error) {
      logger.error('Failed to disable kill switch', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  // ============================================================================
  // Private Helpers
  // ============================================================================

  private authHeaders(): Record<string, string> {
    const headers: Record<string, string> = {};
    if (this.sessionToken) {
      headers['Authorization'] = `Bearer ${this.sessionToken}`;
    }
    return headers;
  }

  private mapProtocol(protocol: VPNProtocol): string {
    const map: Record<string, string> = {
      wireguard: 'wireguard',
      openvpn_udp: 'openvpn-udp',
      openvpn_tcp: 'openvpn-tcp',
      ikev2: 'ikev2',
    };
    return map[protocol] ?? 'openvpn-udp';
  }

  private async applyWireGuardConfig(config: string): Promise<void> {
    const fs = await import('fs/promises');
    await fs.writeFile('/etc/wireguard/wg-cyberghost.conf', config, { mode: 0o600 });
    await this.executeCommand('wg-quick up wg-cyberghost', 30000);
  }

  private async applyOpenVPNConfig(config: string): Promise<void> {
    const fs = await import('fs/promises');
    const configPath = '/tmp/cyberghost.ovpn';
    await fs.writeFile(configPath, config, { mode: 0o600 });
    this.executeCommand(`openvpn --config ${configPath} --daemon`, 5000).catch(() => {});
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }

  /**
   * List streaming-optimized servers for a given service (e.g., "netflix", "hulu")
   */
  async getStreamingServers(service: string): Promise<VPNServerRecord[]> {
    const response = await fetch(
      `${this.apiEndpoint}/servers?feature=streaming&service=${encodeURIComponent(service)}`,
      { headers: this.authHeaders() }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch streaming servers: ${response.statusText}`);
    }

    const data: CyberGhostServerListResponse = await response.json();
    return (data.servers ?? []).map((s) => this.mapServer(s));
  }

  /**
   * List P2P-optimized servers
   */
  async getP2PServers(): Promise<VPNServerRecord[]> {
    const response = await fetch(`${this.apiEndpoint}/servers?feature=p2p`, {
      headers: this.authHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch P2P servers: ${response.statusText}`);
    }

    const data: CyberGhostServerListResponse = await response.json();
    return (data.servers ?? []).map((s) => this.mapServer(s));
  }
}
